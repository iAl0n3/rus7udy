fn main() {
    /* 所有权：
        所有权是 Rust 最独特的特性，它让 Rust 无需 GC 就可以保证内存安全

        Rust 的核心就是所有权
        所有程序在运行时都必须管理它们使用计算机内存的方式
            - 有一些语言有垃圾收集机制，在程序运行时，它们会不断寻找不在使用的内存
            - 在其他语言中，程序员必须显式地分配和释放内存
        Rust 使用了第三种方式：
            - 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则
            - 当程序运行时，所有权特性不会减慢程序的运行速度
    */
    /*  Stack & Heap：
                在像Rust这样的系统级编程语言中，一个值是在 stack 还是 heap 上对语言的行为和你为什么要做某些决定是有重大影响的

            Stack 按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO）
                - 添加数据叫压入栈
                - 移除数据叫弹出栈
            所有存储在 Stack 上的数据必须拥有已知的固定的大小
                - 编译时大小未知的数据或运行时大小可能发生变化的数据必须放在 Heap 上
            Heap 的内存组织性差一些
                - 当你把数据放入 heap 时，你会请求一定数量的空间
                - 操作系统在 heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址
                - 这个过程叫做在 heap 上进行内存分配，有时也仅仅称为“分配”
    */
    /* 存储数据：
                把值压到 stack 上不叫分配
                因为指针是已知固定大小的，可以把指针存放在 stack 上
                    - 但如果想要实际数据，你必须使用指针来定位
                把数据压到 Stack 上比要在 Heap 上分配快的多
                    - 因为操作系统不需要寻找用来存储新数据的空间，那个位置永远在 Stack 的顶端
                在 Heap 上分配内存要做更多的工作：
                    - 操作系统首先需要找到一个足够大的空间来存放数据，然后做好记录方便下次分配
    */

    /* 访问数据：
        访问 Heap 中的数据要比访问 Stack 中的数据慢，因为需要通过指针才能找到 Heap 中的数据
            - 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快
        + 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（Stack 上）
        + 如果数据存放的距离比较远，那么处理速度就会慢一些（Heap 上）
            - 在 Heap 上分配大量的空间也是需要时间的
    */

    /* 函数调用：
            当你的代码调用函数时，值被传入到函数（也包括指向 Heap 的指针）。函数本地的变量被压到 Stack 上。当函数结束后，这些值会从 Stack 上弹出
    */

    /* 所有权存在的原因：
            所有权解决的问题：
                - 跟踪代码的哪些部分正在使用 Heap 的哪些数据
                - 最小化 heap 上的重复数据量
                - 清理 heap 上未使用的数据以避免空间不足
            一旦你懂得了所有权，那么就不需要经常去想 stack 或 heap 了
            管理 Heap 数据是所有权存在的原因，这有助于解释它为什么会这样工作
     */

    /* 所有权规则：
            - 每一个值都有一个变量，这个变量是该值的所有者
            - 每个值同时只能拥有一个所有者
            - 当所有者超出这个作用域（scope）的时，这个值会被删除
        
        Scope 就是程序中一个项目的有效范围
     */
    // S1 不可用
    let s1 = "hello";    // S1 可用
                                // 可以对 S1 进行相关操作



    /* String 类型：
        String 比那些基础标量数据类型更复杂
        字符串字面值：程序里手写的那些字符串值。它们是不可变的

        Rust 还有第二种字符串类型：String
            - 在 Heap 上分配，能够存储在编译时未知数量的文本
    */

    /* 创建 String 类型的值：
        可以使用 from 函数从字符串字面值创建出 String 类型
    */

    let mut s2 = String::from("hello"); // :: 表示　from 是 
    s2.push_str(", World");
    println!("{}", s2);

    /*  为什么 String 类型的值是可以修改的，而字符串字面值却不能修改
            - 因为它们处理内存的方式不同
     */

    /*  内存和分配：
        字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里
            - 速度快，高效，是因为其不可变性
        String 类型，为了支持可变性，需要在 Heap 上分配内存来保存编译时未知的文本内容：
            - 操作系统必须在运行时来请求内存，这步通过调用 String::from 来实现
            - 当用完 String 之后，需要使用某种方式将内存返回给操作系统，这步，在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存
            - 没有 GC，就需要我们去识别内存何时不再使用，并调用代码将它返回
                + 如果忘了，就会浪费内存
                + 如果提前做了，变量就会非法
                + 如果做了两次，也是 Bug，必须一次分配对应一次释放
        Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统（Drop 函数）
    */

    /* 变量和数据交互的方式：移动（Move）
        多个变量可以与同一个数据使用同一种独特的方式来交互
     */
    let x = 5;
    let y = x;  // 整数是已知且固定大小的简单的值，这两个5被压到了 stack 中

    // Move：String 版本
    let s3 = s2;    // 并没有负责指针所指向的 heap 上的数据
    /*
        当变量离开作用域时，Rust 会自动调用 drop 函数，并将变量使用的 heap 内存释放
        当 s2 s3 两个变量离开作用域时，它们都会尝试释放相同的内存：
            - 二次释放（double free） bug
        为了保证内存安全
            - Rust 没有尝试尝试复制被分配的内存
            - Rust 让 S2 失效
                + 当 S3 离开作用域的时候，Rust 不需要释放任何东西
     */

    /*  
        - 浅拷贝（shallow copy）
        - 深拷贝（deep copy）
        你也许会将复制指针，长度，容量视为浅拷贝，但由于 Rust 让 S2 失效了，所以我们用一个新的术语：移动（Move）
     */
}   // S1 作用域到此结束，S1 不在可用