fn main() {
/* 变量：
    声明变量使用 let 关键字
    默认情况下，变量是不可变的
    声明变量时，使用 mut 使变量可变
 */
    let mut x = 5;
    println!("The value is {}", x);
    x = 6;
    println!("The value is {}", x);

/* 变量和常量：
    常量在绑定值后也是不可变的，但是它与不可变的变量有很多区别：
        - 不可以使用 mut ，常量永远是不可变的
        - 声明常量使用 const 关键字，它的类型必须被标注
        - 常量可以在任何作用域内进行声明，包括全局作用域
        - 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值
    程序运行期间，常量在其声明的作用域内一直有效
    命名规范：Rust 里常量使用大写字母，每个单词之间使用下划线分开，例如：MAX_POINTS
    例子：const MAX_POINTS:u32 = 100_000;
 */
    const MAX_POINTS:u32 = 100_000;

/* shadowing(隐藏)：
    可以使用相同的名字命名新的变量，新的变量就会 shadow 之前声明的同名变量
        - 在后续代码中这个变量名代表的就是新的变量

    shadow 和把变量标记为 mut 是不一样的
        - 如果不使用 let 关键字，那么重新给非 mut 的变量赋值会导致编译时报错
        - 而使用 let 声明的同名新变量，也是不可变的
        - 使用 let 声明的同名新变量，它的类型可以与之前不同
 */
    let spaces = "          ";
    let spaces = spaces.len();
    
    println!("{}", spaces);

/* 数据类型：
    Rust 是静态编译语言，在编译时必须知道所有变量的类型
        - 基于使用的值，编译器通常能够推断出它的具体类型
        - 但如果可能的类型比较多（例如把 String 类型转换为整数的 parse 方法）， 就必须添加类型标准，否则编译就会报错
 */
    let guess: u32 = "42".parse().expect("Not a number!");
    println!("{}", guess);

/* 标量类型：
    一个标量类型代表一个单一的值
    Rust 有四个主要的标量类型：
        - 整数类型
        - 浮点类型
        - 布尔类型
        - 字符类型

    1. 整数类型
        - 整数类型没有小数部分
        - 例如 u32 就是一个无符号的整数类型，占32位空间
        - 无符号类型以 u 开头
        - 有符号类型以 i 开头
        - isize 和 usize 类型的位数由程序运行的计算机的架构所决定
            > 使用 isize 和 usize 的主要场景是针对某种集合进行索引操作
    > 整数溢出：
    > - 调试模式下编译：Rust 会检查整数溢出，如果发生，则程序在运行时就会 panic
    > - 发布模式下编译（--release）：Rust 不会检查可能导致 panic 的整数溢出，如果发生溢出，Rust 会执行环绕操作： 256 --> 0, 257 --> 1，但程序不会 panic

    2. 浮点类型
        Rust 有两种基础的浮点类型，也就是含有小数部分的类型
        - f32，32位，单精度
        - f64，64位，双精度（默认类型）
    
    3. 数值操作：加减乘除余
    4. 布尔类型：true 和 false，一个字节大小
    5. 字符类型：char 类型被用来描述语言中最基础的单个字符，字符类型的字面值使用用单引号，占用4字节大小，是 Unicode
*/

/* 复合类型：
    复合类型可以将多个值放在一个类型里
    Rust 提供了两种基础的复合类型，一种是 元组（Tuple） 数组

    Tuple:
        - Tuple 可以将多个类型的多个值放在一个类型里
        - Tuple 的长度是固定的，一旦声明就无法改变

    创建一个 Tuple：
        - 在小括号内，将值用逗号隔开
        - Tuple 中每个位置对应一个类型，Tuple中各元素的类型不必相同
    
    获取 Tuple 的元素值：
        - 可以使用模式匹配来解构（destructure）一个 Tuple 来获取元素值
 */
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    // println!("{} {} {}", tup.0, tup.1, tup.2);

    // 解构一个 Tuple
    let (x, y, z) = tup;
    println!("{} {} {}", x, y, z);
    
    // 访问 Tuple 的元素：在 Tuple 元素中使用点标记法，后接元素的索引号
    println!("{} {} {}", tup.0, tup.1, tup.2);

/* 数组：
    声明一个数组：在中括号内，各值用逗号隔开
 */
    let a = [1, 2, 3, 4, 5];

/* 数组的用处：
        - 如果想让你的数据存在 stack （栈）而不是 heap （堆）上，或者想保证有固定数量的元素，这时使用数组更有好处
        - 数组没有 Vector 灵活
            - Vector 和数组类似，它由标准库提供
            - Vector 的长度可以改变
            - 如果你不确定应该用数组还是 Vector ，那么估计你应该用 Vector
*/
    let months = [
        "January", 
        "February", 
        "March", 
        "April", 
        "May", 
        "June", 
        "July", 
        "August", 
        "September", 
        "October", 
        "November", 
        "December"
    ];

/* 数组的类型：
    - 数组的类型以这种形式表示：[类型; 长度]
 */
    let a:[i32;5] = [1, 2, 3, 4, 5];
/* 另一种声明数组的方法：
    - 如果数组的每个元素值都相同，那么可以在：
        1. 在中括号内指定初始值
        2. 然后是一个 “;”
        3. 最后是数组的长度
 */
    let b = [3;5]; // let b = [3, 3, 3, 3, 3];

/* 如何访问数组的元素：
    数组是 Stack 上分配的单个块的内存
    可以使用索引来访问数组的元素
 */
    let first = months[0];
    let second = months[1];
/* 
    如果访问的索引超出了数组的范围，那么：
        - 编译会通过
        - 运行会报错（runtime 时会 panic）
            + rust 不会允许其继续访问相应地址的内存
 */
}
